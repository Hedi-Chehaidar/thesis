% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Approach}\label{chapter:approach}

\section{Dynamic Programming}
\label{dp}

The first contirbution of the thesis to the FSST algorithm of Figure~\ref{algorithm3} is replacing the $st.findLongestSymbol$ method with a DP function that gives "one" best symbol given the position in the text to encode (or training text in compressCount) with a single table lookup in $O(1)$ runtime. This table called $opt$ was constructed simultaneously with the DP table, serving as a solution recovery.
\newline

\noindent
To understand the utility of the used DP function in the code, let's first define the more intuitive DP function for $0 \le i \le n$ (where $n$ is the text length) as: $dp[i] =$ smallest compressed size of the first $i$ bytes of the given text. So the result for the whole text is in $dp[n]$. The base case is $dp[0] = 0$ as the compression of an empty string is always an empty string.
The recurrence is defined for each other value as: 
\[
dp[i] = \min(2 + dp[i-1], 1 + \min\limits_{\substack{0 \le j < i \\ s[j:i] \in symbols}} dp[j])
\]
where $s[j:i]$ denotes the substring of the text from position $j$ to $i-1$ (0-indexed). The formula simply chooses between either escaping the current byte or selecting one symbol that minimizes the dp value.
In the first case, an overhead of two bytes must be added resulted in the escape byte followed by the raw byte from the string during encoding. In the second case, there is an added one byte for the code of the chosen symbol. Then all qualifying symbols are the ones that match a suffix of the first $i$ bytes, thus the constraints under the second $min$.

The problem with this formula is that the qualifying symbols are ending at the position $i$ where building the $opt$ table requires knowing one best symbol beginning at a position $i$. So implementing this dp function will not help by filling the $opt$ table simultaneously, as we still need another dedicated function that also iterates over qualifying symbols again at each position, but this time the qualifying symbols are beginning at the current position and choosing one best symbol will depend on the DP values computed beforehand.
\newline

\noindent
As a consequence, I used this DP function instead, defined for $0 \le i \le n$ as: $dp[i] =$ smallest compressed size of the last $n-i$ bytes the given text. This is equivalent to say that $dp[i]$ is the smallest compressed size of the suffix of the given text tsarting at position $i$ (0-indexed). So the result for the whole text is in $dp[0]$. The base case is $dp[n] = 0$ as the suffix from position $n$ is an empty string.
The recurrence is defined for each other position as:
\[
dp[i] = \min(2 + dp[i+1], 1 + \min\limits_{\substack{i < j \le n \\ s[i:j] \in symbols}} dp[j]).
\]
The two options to choose from are the same as in the previous formula, but qualifying symbols to choose from must now begin at position $i$ as we are now calculating the results for suffixes instead of prefixes of the given text.
\newline

\noindent
This DP problem is a segmentation problem where each segment is either a symbol, the escape code or a raw byte of the string that must follow the escape code. All segments have the same cost and we want to minimize the number of segments used to compress a given text. The first formula builds a bottom-up solution, while the second formula builds a top-down solution. Both should give the same result for the whole text as they are solving the same problem. The following code represents the python implementation of the DP function $st.buildDP$ that fills both the DP table and the $opt$ table in a single pass.

\begin{figure}[htpb]
  \centering
  \begin{tabular}{c}
  \begin{lstlisting}[language=Python]
    n = len(data) # data is the given text to encode, or to use for compressCount
    self.dp = [0] * (n+1)
    self.opt = [0] * n
    for i in reversed(range(n)):
        self.opt[i] = data[i] 
        self.dp[i] = self.dp[i+1] + 2 # Fallback value: escape the byte
        start = self.sIndex[data[i]] # index of first symbol beginning with the byte at i
        end = self.sIndex[data[i] + 1]
        for code in range(start, end):
            sym = self.symbols[code]
            L = len(sym)
            if i + L <= len(data) and self.dp[i] > 1 + self.dp[i + L] and data[i:i + L] == sym:
                self.dp[i] = 1 + self.dp[i + L]
                self.opt[i] = code
  \end{lstlisting}
  \end{tabular}
  \caption{Python implementation of the DP function.}
  \label{dp_python}
\end{figure}

As the code shows, the DP table is 


\section{$3^{rd}$ Counter}

\section{Symbol Pruning}


\begin{comment}
Citation test~\parencite{latex}.

Acronyms must be added in \texttt{main.tex} and are referenced using macros. The first occurrence is automatically replaced with the long version of the acronym, while all subsequent usages use the abbreviation.

E.g. \texttt{\textbackslash ac\{TUM\}, \textbackslash ac\{TUM\}} $\Rightarrow$ \ac{TUM}, \ac{TUM}

For more details, see the documentation of the \texttt{acronym} package\footnote{\url{https://ctan.org/pkg/acronym}}.
\subsection{Subsection}

See~\autoref{tab:sample}, \autoref{fig:sample-drawing}, \autoref{fig:sample-plot}, \autoref{fig:sample-listing}.

\begin{table}[htpb]
  \caption[Example table]{An example for a simple table.}\label{tab:sample}
  \centering
  \begin{tabular}{l l l l}
    \toprule
      A & B & C & D \\
    \midrule
      1 & 2 & 1 & 2 \\
      2 & 3 & 2 & 3 \\
    \bottomrule
  \end{tabular}
\end{table}

\begin{figure}[htpb]
  \centering
  % This should probably go into a file in figures/
  \begin{tikzpicture}[node distance=3cm]
    \node (R0) {$R_1$};
    \node (R1) [right of=R0] {$R_2$};
    \node (R2) [below of=R1] {$R_4$};
    \node (R3) [below of=R0] {$R_3$};
    \node (R4) [right of=R1] {$R_5$};

    \path[every node]
      (R0) edge (R1)
      (R0) edge (R3)
      (R3) edge (R2)
      (R2) edge (R1)
      (R1) edge (R4);
  \end{tikzpicture}
  \caption[Example drawing]{An example for a simple drawing.}\label{fig:sample-drawing}
\end{figure}

\begin{figure}[htpb]
  \centering

  \pgfplotstableset{col sep=&, row sep=\\}
  % This should probably go into a file in data/
  \pgfplotstableread{
    a & b    \\
    1 & 1000 \\
    2 & 1500 \\
    3 & 1600 \\
  }\exampleA
  \pgfplotstableread{
    a & b    \\
    1 & 1200 \\
    2 & 800 \\
    3 & 1400 \\
  }\exampleB
  % This should probably go into a file in figures/
  \begin{tikzpicture}
    \begin{axis}[
        ymin=0,
        legend style={legend pos=south east},
        grid,
        thick,
        ylabel=Y,
        xlabel=X
      ]
      \addplot table[x=a, y=b]{\exampleA};
      \addlegendentry{Example A}
      \addplot table[x=a, y=b]{\exampleB};
      \addlegendentry{Example B}
    \end{axis}
  \end{tikzpicture}
  \caption[Example plot]{An example for a simple plot.}\label{fig:sample-plot}
\end{figure}

\begin{figure}[htpb]
  \centering
  \begin{tabular}{c}
  \begin{lstlisting}[language=SQL]
    SELECT * FROM tbl WHERE tbl.str = "str"
  \end{lstlisting}
  \end{tabular}
  \caption[Example listing]{An example for a source code listing.}\label{fig:sample-listing}
\end{figure}
\end{comment}